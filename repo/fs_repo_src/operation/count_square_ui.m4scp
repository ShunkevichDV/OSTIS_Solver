
#include "scp_keynodes.scsy"
#include "etc_questions.scsy"
#include "com_keynodes.scsy"
#include "lib_search.scsy"
#include "lib_check.scsy"
#include "lib_gen.scsy"
#include "lib_answer.scsy"
#include "lib_set.scsy"


program(init_op,
[[
	// Вызываемая SCP-программа
	count_square;	
	// Ключевой узел, обозначающий инициированный вопрос
	q_initiated;
	// Событие, на которое реагирует обработчик(проведение выходящей дуги из узла)
	catch_output_arc;
]],
[{
}],
{[
]}
)
// Установка обработчика события на проведение дуги  из узла "инициированный запрос" 
sys_set_event_handler([
	1_: fixed_: catch_output_arc,
	2_: fixed_: count_square,
	3_: fixed_: {1_: q_initiated}
])

return()
	
end



procedure(count_square,
[[

	here=/"\n\nMESSAGE!!!!!!!!!!!!!!!!!!!!!!!!\n\n"/;
	
	// Ключевой узел, обозначающий запрос
	q_count_square;
	
	// Ключевой узел, обозначающий инициированный вопрос
	q_initiated;
	
	// Ключевой узел, обозначающий вопрос
	question;
	
	// Ключевой узел, обозначающий запрос значения величины
	q_var_value;

	// Процедура для генерации ответа
	answer_make;
	
]],
[{
	handler, element,
	arcFromRequest, arcFromQuestion, 
	location, segments,
	questionLink,
	arcForChecking, arcVar, attributeArc, nodeVar, checkingNode,
	object, valueNode, questionNode, result, tresult,
	answer
}],
{[
	1_: in_: handler, 
	2_: in_: element, 
	3_: in_: arcFromQuestion, 
	4_: in_: questionLink
]}
)


// Получение сегмента, в котором находится узел отношения периметр
sys_get_location([
	1_: fixed_: q_count_square,
	2_: assign_: location
])

// Установка найденного сегмента как основного
sys_set_default_segment([
	1_: fixed_: location
])

// Разворачивание установленного сегмента
sys_spin_segment([
	1_: fixed_: location,
	2_: assign_: segments
])

searchElStr3([
	1_: fixed_: q_count_square,
	2_: assign_: const_: pos_: arc_: arcFromRequest,
	3_: fixed_: questionLink
], , finishOperation)

searchElStr3([
	1_: fixed_: questionLink,
	2_: assign_: const_: pos_: arc_: arcVar,
	3_: assign_: const_: node_: object
])

printNl([1_: here])
printNl([1_: object])

genEl([
	1_: assign_: const_: node_: valueNode
])
callReturn([
	1_: fixed_: c_s_o,
	2_: fixed_: {[
		1_: tresult,
		2_: valueNode
	]}
], , , finish_operation)


// Находим значение площади
	callReturn([
		1_: fixed_: search_quantity_value,
		2_: fixed_: {[
			1_: valueNode,
			2_: result
		]}
	])

	// Генерируем ответ 
	// Генерируем узел ответа
	genElStr3([
		1_: assign_: node_: const_: answer,
		2_: assign_: pos_: const_: arcVar,
		3_: fixed_: result
	])
	/////////////////////////////////////////////////////
	// Call of the answer making procedure
	callReturn([
		1_:	fixed_: answer_make,
		2_:	fixed_: {[
				1_: questionLink,
				2_: answer
			]}
		]
	)

label(finishOperation)
	
return()
	
end

procedure(c_s_o,
[[	
	One =n= 1;
	Two =n= 2;
]],
[{
	target, result_set, rootNumber, ElemA, CopyA, SquareA, R, B,
	node1, node2, arc1, arc2, arc3, set1, set2, e, BTwoA	
}],
{[
	1_: in_: target,
	2_: in_: out_: result_set
]}
)

genEl([1_: assign_: rootNumber])

varAssign([1_: assign_: ElemA,
2_: fixed_: One]) 

varAssign([1_: assign_: CopyA,
2_: fixed_: One]) 

varAssign([1_: assign_: SquareA,
2_: fixed_: One]) 

printNl([1_:fixed_:/"Number:"/])
printNl([1_: fixed_: target])
printNl([1_:fixed_:/"Result:"/])

printNl([1_:fixed_:/"AAAAAAA 1:"/])

genEl([
	1_: assign_: const_: node_: R
])

genEl([
	1_: assign_: const_: node_: B
])

genEl([
	1_: assign_: const_: node_: BTwoA
])

genEl([
	1_: assign_: const_: node_: set1
])

printNl([1_:fixed_:/"AAAAAAA 2:"/])

label(begin)
//если квадрат числа ElemA больше BasicNumber, то число найдено

ifEq([1_: fixed_: SquareA, 2_: fixed_: target],end_out,,) 
ifGr([1_: fixed_: SquareA, 2_: fixed_: target],next_out,,) 
label(next) 

add([1_: fixed_: ElemA, 2_: fixed_: ElemA, 3_: One]) 

printNl([1_:fixed_:/"here 1:"/])

varAssign([1_: assign_: CopyA, 2_: fixed_: ElemA]) 

mult([1_: assign_: SquareA, 2_: fixed_: ElemA, 3_: fixed_: ElemA ],begin, begin, begin) 

label(next_out) 

mult([1_: assign_: R, 2_: fixed_: Two, 3_: fixed_: ElemA]) 

printNl([1_:fixed_:/"here 2:"/])

printNl([1_:fixed_: SquareA])

printNl([1_:fixed_: target])

sub([1_: assign_: B, 2_: fixed_: target, 3_: fixed_: SquareA]) 

div([1_:BTwoA, 2_: B, 3_: R]) 

add([1_:RootNumber, 2_:ElemA, 3_: BTwoA])
toStr([1_: fixed_: set1, 2_: fixed_: RootNumber])

printNl([1_:fixed_:/"here 3:"/])

printNl([1_:fixed_:RootNumber],endpr,endpr,endpr)

label(end_out) 
printNl([1_:fixed_:/"end_out:"/])
printNl([1_:fixed_:ElemA])

label(endpr)
printNl([1_:fixed_:/"endpr:"/])
return()
end